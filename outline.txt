1. Introduction
2. Static code analysis, Roslyn
  - Brief definition of compilers
  - What is static code analysis, where does it fit in compilation process
  - What is Roslyn
  - How to perform static code analysis with Roslyn
3. Other tools for code analysis available for C#
  - Resharper,
  - FxCop
  - StyleCop
  - new DotNetAnalyzers available thanks to Roslyn
  - ...
4. Current situation in Kentico
  - existing BugHunter as console application running on build-boxes, what is it used for
  - attempts to rewrite BH to Roslyn - not so successful Bachelor thesis by another student (huge performance problems, basically one to one with the old console app, does not leverage of Roslyn type system, everything based on strings, therefore many missed diagnostic problems)
  - using Resharper and FxCop - describe how these influences our solution
  - what are the main reasons we seek to rewrite the old BugHunter to Roslyn
    - type checking not only string comparisons
      - many cases that were not discoverable by string comparison were uncovered
    - excluding some files or folders from being processed by console app was extremely cumbersome, with Rosyln ignore comment is enough and pretty explicit
    - support for "live" analysis in VS and ability to provide code fixes
5. Technical solution
  - description of what was actually implemented
  - the project structure, some diagrams
  - mention problems that came along and how they were solved
    - eagerness not to rely on string constants was ruined by too many obstacles that go with creating a NuGet package (...elaborate on this one)
      - how to actually know we are looking for right things and did not misspell something --> tests always reference current version of Kentico.Libraries (NuGet package). If there is any typo in either source code of test files or analyzers, the tests will fail (needed to manually turn this feature on since the boilerplate generated by Microsoft project did not support this)
  - extensibility of solution (how simple it is to add new analyzers)
6. Performance
  - no real standard how to test 3rd party Roslyn analyzers
    - inspiration by StyleCopTester project 
      - originally designed to compare the performance of different Roslyn versions with StyleCopAnalyzers on some well known open source libraries)
      - adopted the project to run the BugHunter against generated smaple project
      - needed to introduce a tool for generating custom test project to test the performance - no open source project would be helpful as in the case of the original StyleCopTester; since the BugHunter only makes sense to be run against projects that have Kentico.Libraries as dependency, or put simply: the types it searches for must be available at the time of running the analyzers
      - then a PowerShell script would run the PerformanceTest console application against generated SampleProject
      - the result is the time it took for the project to be compiled and all diagnostics to be raised
   - this tool will be used to try different approaches to writing analyzers, where most performant (and still readable and maintainable) solution will be picked
  -  another option provided by Microsoft is to run the csc.exe with /reportanalyzer switch. This will output the total time spent by analyzers on the CPU and also the relative times of the separate analyzers
    - this tool provided great insight to spot the weak points in the implementation and started the initiative to make the slowest parts more performant
  - then some other tests will be conducted with a DotNetBenchmark framework to test slowest analyzers as separate units and tweak with different implementations -- fastest will be chosen for the final version
  - another comparison for whole BugHunter with optimized analyzers will be performed using PerformanceTester tool and results will be compared to the original naive implementation
  - after the tool is deployed I plan to collect CI build times and compare them with the state before 
7. Deployment of the analyzers
  - this chapter will describe the current state of the project and how the analyzers were deployed, how they are used at the time of writing at Kentico
8. Conclusion
  - how to maintain the tool, how easy it is to add new analyzers, how it helped the development teams...
  
Appendix
A. Upgrades and versioning
  - step by step guide on how to keep BugHunter up to date with the current version of Kentico
  - how to deploy a new version of BugHunter
  