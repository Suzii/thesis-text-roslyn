1. Introduction
  - motivation for the thesis, how static code analysis helps code reviews, why kentico needs a tool like this
2. Static code analysis, 
  - code quality,
  - what is a code review
  - what is static code analysis
    - suppport tool for code reviews, 
    - detecting common pitfalls and issues in the code before manual code review takes place
    - where does it fit in compilation process
3. Roslyn - compiler as a service
  - brief definition of compilers
  - what is Roslyn
    - description of layers, the API
  - how to perform static code analysis with Roslyn
    - writing anlyzers and code fixes / code refactorings
3. Other tools for code analysis available for C#
  - Resharper,
  - FxCop
  - StyleCop
  - new DotNetAnalyzers available thanks to Roslyn
  - ...
4. Current situation in Kentico
  - existing BugHunter as console application
    - what is it used for,
    - running on build-boxes, 
  - attempts to rewrite BH to Roslyn 
    - not so successful Bachelor thesis by another student (huge performance problems, implementation basically one to one with the old console app, does not leverage of Roslyn type system, everything based on strings, therefore many missed diagnostic problems)
  - using Resharper and FxCop 
    - describe how these influences proposed solution
  - what are the main reasons we seek to rewrite the old BugHunter to Roslyn
    - type checking instead of dummy string comparisons
    - many cases that were not discoverable by string comparison were uncovered
    - excluding some files or folders from being processed by console app was extremely cumbersome, with Rosyln ignore comment is enough and a more explicit
    - support for "live" analysis in VS and ability to provide code fixes
      - great for new team members and junior programmers
5. Technical solution -- DRAFT VERSION, will be most likely changed a lot
  - description of what was actually implemented
  - the project structure, diagrams
  - mention problems that came along and how they were solved
    - eagerness not to rely on string constants was ruined by too many obstacles that go with creating a NuGet package (...elaborate on this one)
    - how to actually know we are looking for right things and did not misspell something --> tests always reference current version of Kentico.Libraries (NuGet package). If there is any typo in either source code of test files or analyzers, the tests will fail (needed to manually turn this feature on since the boilerplate generated by Microsoft project did not support this)
  - extensibility of solution (how simple it is to add new analyzers)
  - ConfigureGeneratedCodeAnalysis - big boost when roslyn API allowed to opt out for analyzer to be run on generated code. Before, heuristics had to be performed by analyzers themselves on every callback
   https://github.com/dotnet/roslyn/issues/6998
   https://github.com/dotnet/roslyn/pull/7526
  - semantic model browser - completely redundant 
    /// https://github.com/dotnet/roslyn-analyzers/blob/master/src/Roslyn.Diagnostics.Analyzers/Core/DoNotInvokeDiagnosticDescriptor.cs
  - creating new objects in callback methods --> impact???
6. Performance
  - no real standard how to test 3rd party Roslyn analyzers
    - inspiration by StyleCopTester project 
      - originally designed to compare the performance of different Roslyn versions with StyleCopAnalyzers on some well known open source libraries)
      - adopted the project to run the BugHunter against generated smaple project
      - needed to introduce a tool for generating custom test project to test the performance - no open source project would be helpful as in the case of the original StyleCopTester; since the BugHunter only makes sense to be run against projects that have Kentico.Libraries as dependency, or put simply: the types it searches for must be available at the time of running the analyzers
      - then a PowerShell script would run the PerformanceTest console application against generated SampleProject
      - the result is the time it took for the project to be compiled and all diagnostics to be raised
   - this tool will be used to try different approaches to writing analyzers, where most performant (while still readable and maintainable) solution will be picked
  -  another option provided by Microsoft is to run the csc.exe with /reportanalyzer switch. This will output the total time spent by analyzers on the CPU and also the relative times of the separate analyzers
    - this tool provided great insight to point out the weak spots in the implementation and started the initiative to make the slowest parts more performant
  - then some other tests will be conducted with a DotNetBenchmark framework to test slowest analyzers as separate units and tweak with different implementations -- fastest will be chosen for the final version
  - another comparison for whole BugHunter with optimized analyzers will be performed using PerformanceTester tool and results will be compared to the original naive implementation
  - after the tool is deployed, the plan is to collect CI build times and compare them with the state before 
  - sum up the feedback from developers that use tool daily (more details should be in Appendix)
7. Deployment of the analyzers
  - this chapter will describe the current state of the project and how the analyzers were deployed, how they are used at the time of writing at Kentico
8. Conclusion
  - how to maintain the tool, 
  - how easy it is to add new analyzers, 
  - how it helped the development teams...
  
Appendix
A. Upgrades and versioning
  - step by step guide on how to keep BugHunter up to date with the current version of Kentico
  - how to deploy a new version of BugHunter
B. Feedback from developers
  